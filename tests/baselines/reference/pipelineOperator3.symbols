=== tests/cases/conformance/expressions/pipelineOperator/pipelineOperator3.ts ===
declare const xs: number[];
>xs : Symbol(xs, Decl(pipelineOperator3.ts, 0, 13))

declare function map<T, U>(fn: (item: T) => U): (arr: T[]) => U[];
>map : Symbol(map, Decl(pipelineOperator3.ts, 0, 27))
>T : Symbol(T, Decl(pipelineOperator3.ts, 1, 21))
>U : Symbol(U, Decl(pipelineOperator3.ts, 1, 23))
>fn : Symbol(fn, Decl(pipelineOperator3.ts, 1, 27))
>item : Symbol(item, Decl(pipelineOperator3.ts, 1, 32))
>T : Symbol(T, Decl(pipelineOperator3.ts, 1, 21))
>U : Symbol(U, Decl(pipelineOperator3.ts, 1, 23))
>arr : Symbol(arr, Decl(pipelineOperator3.ts, 1, 49))
>T : Symbol(T, Decl(pipelineOperator3.ts, 1, 21))
>U : Symbol(U, Decl(pipelineOperator3.ts, 1, 23))

declare function filter<T>(fn: (item: T) => boolean): (arr: T[]) => T[];
>filter : Symbol(filter, Decl(pipelineOperator3.ts, 1, 66))
>T : Symbol(T, Decl(pipelineOperator3.ts, 2, 24))
>fn : Symbol(fn, Decl(pipelineOperator3.ts, 2, 27))
>item : Symbol(item, Decl(pipelineOperator3.ts, 2, 32))
>T : Symbol(T, Decl(pipelineOperator3.ts, 2, 24))
>arr : Symbol(arr, Decl(pipelineOperator3.ts, 2, 55))
>T : Symbol(T, Decl(pipelineOperator3.ts, 2, 24))
>T : Symbol(T, Decl(pipelineOperator3.ts, 2, 24))

const result = xs
>result : Symbol(result, Decl(pipelineOperator3.ts, 4, 5))
>xs : Symbol(xs, Decl(pipelineOperator3.ts, 0, 13))

    |> map(x => x.toString())
>map : Symbol(map, Decl(pipelineOperator3.ts, 0, 27))
>x : Symbol(x, Decl(pipelineOperator3.ts, 5, 11))
>x.toString : Symbol(Number.toString, Decl(lib.es5.d.ts, --, --))
>x : Symbol(x, Decl(pipelineOperator3.ts, 5, 11))
>toString : Symbol(Number.toString, Decl(lib.es5.d.ts, --, --))

    |> filter(x => x === '1')
>filter : Symbol(filter, Decl(pipelineOperator3.ts, 1, 66))
>x : Symbol(x, Decl(pipelineOperator3.ts, 6, 14))
>x : Symbol(x, Decl(pipelineOperator3.ts, 6, 14))

